use crate::ast::*;
use std::collections::HashMap;

pub struct NVMAssemblyGenerator {
    output: String,
    labels: HashMap<String, String>,
    label_counter: u32,
    local_vars: HashMap<String, u8>,
    next_local: u8,
    loop_stack: Vec<(String, String)>, // (break_label, continue_label)
    current_function: String,
}

impl NVMAssemblyGenerator {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            labels: HashMap::new(),
            label_counter: 0,
            local_vars: HashMap::new(),
            next_local: 0,
            loop_stack: Vec::new(),
            current_function: String::new(),
        }
    }

    pub fn generate(&mut self, program: &Program) -> String {
        
        self.output.push_str(".NVM0\n");
        self.output.push_str("; Generated by Perano Language Compiler\n\n");

        
        if let Some(main_func) = program.functions.iter().find(|f| f.name == "main") {
            self.generate_function(main_func, program);
        }

        
        for func in &program.functions {
            if func.name != "main" {
                self.generate_function(func, program);
            }
        }

        
        for (_module_name, module) in &program.modules {
            for func in &module.functions {
                if func.is_exported {
                    let full_name = format!("{}_{}", module.name, func.name);
                    self.generate_module_function(func, &full_name, program);
                }
            }
        }

        self.output.clone()
    }

    fn generate_function(&mut self, func: &Function, program: &Program) {
        self.current_function = func.name.clone();
        self.local_vars.clear();
        self.next_local = 0;

        self.output.push_str(&format!("; Function: {}\n", func.name));
        self.output.push_str(&format!("func_{}:\n", func.name));

        
        for (i, param) in func.params.iter().enumerate() {
            self.local_vars.insert(param.name.clone(), i as u8);
            self.next_local = (i + 1) as u8;
            self.output.push_str(&format!("    ; param: {} -> local {}\n", param.name, i));
        }

        
        for stmt in &func.body {
            self.generate_statement(stmt, program);
        }

        
        if func.name == "main" {
            self.output.push_str("    ; Main returns 0 by default\n");
            self.output.push_str("    push 0\n");
            self.output.push_str("    syscall exit\n");
        }
        
        self.output.push_str("    ret\n\n");
    }

    fn generate_module_function(&mut self, func: &Function, full_name: &str, program: &Program) {
        self.current_function = full_name.to_string();
        self.local_vars.clear();
        self.next_local = 0;

        self.output.push_str(&format!("; Module Function: {}\n", full_name));
        self.output.push_str(&format!("func_{}:\n", full_name));

        for (i, param) in func.params.iter().enumerate() {
            self.local_vars.insert(param.name.clone(), i as u8);
            self.next_local = (i + 1) as u8;
            self.output.push_str(&format!("    ; param: {} -> local {}\n", param.name, i));
        }

        for stmt in &func.body {
            self.generate_statement(stmt, program);
        }

        self.output.push_str("    ret\n\n");
    }

    fn generate_statement(&mut self, stmt: &Statement, program: &Program) {
        match stmt {
            Statement::VarDecl { name, var_type, value } => {
                self.output.push_str(&format!("    ; var {} {}\n", name, 
                    var_type.as_ref().map(|t| t.as_str()).unwrap_or("int")));
                
                if let Some(init_expr) = value {
                    self.generate_expression(init_expr, program);
                } else {
                    self.output.push_str("    push 0\n");
                }
                
                let local_index = self.next_local;
                self.local_vars.insert(name.clone(), local_index);
                self.next_local += 1;
                
                self.output.push_str(&format!("    store {}\n", local_index));
            }

            Statement::Assignment { name, value } => {
                self.output.push_str(&format!("    ; {} = ...\n", name));
                self.generate_expression(value, program);
                
                if let Some(&local_index) = self.local_vars.get(name) {
                    self.output.push_str(&format!("    store {}\n", local_index));
                } else {
                    self.output.push_str(&format!("    ; ERROR: Variable not found: {}\n", name));
                }
            }

            Statement::If { condition, then_body, else_body } => {
                self.output.push_str("    ; if condition\n");
                self.generate_expression(condition, program);
                
                let else_label = self.generate_label("else");
                let end_label = self.generate_label("endif");
                
                self.output.push_str(&format!("    jz32 {}\n", else_label));
                
                self.output.push_str("    ; then block\n");
                for stmt in then_body {
                    self.generate_statement(stmt, program);
                }
                
                self.output.push_str(&format!("    jmp32 {}\n", end_label));
                
                self.output.push_str(&format!("{}:\n", else_label));
                
                if let Some(else_stmts) = else_body {
                    self.output.push_str("    ; else block\n");
                    for stmt in else_stmts {
                        self.generate_statement(stmt, program);
                    }
                }
                
                self.output.push_str(&format!("{}:\n", end_label));
            }

            Statement::For { init, condition, post, body } => {
                self.output.push_str("    ; for loop\n");
                
                if let Some(init_stmt) = init {
                    self.output.push_str("    ; init\n");
                    self.generate_statement(init_stmt, program);
                }
                
                let loop_start = self.generate_label("for_start");
                let loop_end = self.generate_label("for_end");
                let loop_continue = self.generate_label("for_continue");
                
                self.loop_stack.push((loop_end.clone(), loop_continue.clone()));
                
                self.output.push_str(&format!("{}:\n", loop_start));
                
                if let Some(cond) = condition {
                    self.output.push_str("    ; condition\n");
                    self.generate_expression(cond, program);
                    self.output.push_str(&format!("    jz32 {}\n", loop_end));
                }
                
                self.output.push_str("    ; body\n");
                for stmt in body {
                    self.generate_statement(stmt, program);
                }
                
                self.output.push_str(&format!("{}:\n", loop_continue));
                
                if let Some(post_stmt) = post {
                    self.output.push_str("    ; post\n");
                    self.generate_statement(post_stmt, program);
                }
                
                self.output.push_str(&format!("    jmp32 {}\n", loop_start));
                
                self.output.push_str(&format!("{}:\n", loop_end));
                self.loop_stack.pop();
            }

            Statement::Return(value) => {
                if let Some(expr) = value {
                    // self.output.push_str("    ; return\n");
                    // self.generate_expression(expr, program);
                }
                // self.output.push_str("    ret\n");
            }

            Statement::Expression(expr) => {
                self.generate_expression(expr, program);
                // self.output.push_str("    pop  ; discard result\n");
            }

            _ => {
                self.output.push_str("    ; unsupported statement\n");
            }
        }
    }

    fn generate_expression(&mut self, expr: &Expression, program: &Program) {
        match expr {
            Expression::Number(n) => {
                self.output.push_str(&format!("    push {}\n", n));
            }

            Expression::String(_s) => {
                self.output.push_str("    push 0  ; string not supported\n");
            }

            Expression::Identifier(name) => {
                if let Some(&local_index) = self.local_vars.get(name) {
                    self.output.push_str(&format!("    load {}  ; {}\n", local_index, name));
                } else {
                    self.output.push_str(&format!("    ; ERROR: Variable not found: {}\n", name));
                    self.output.push_str("    push 0\n");
                }
            }

            Expression::Binary { op, left, right } => {
                self.generate_expression(left, program);
                self.generate_expression(right, program);
                
                match op {
                    BinaryOp::Add => self.output.push_str("    add\n"),
                    BinaryOp::Sub => self.output.push_str("    sub\n"),
                    BinaryOp::Mul => self.output.push_str("    mul\n"),
                    BinaryOp::Div => self.output.push_str("    div\n"),
                    BinaryOp::Mod => self.output.push_str("    mod\n"),
                    BinaryOp::Equal => self.output.push_str("    eq\n"),
                    BinaryOp::NotEqual => self.output.push_str("    neq\n"),
                    BinaryOp::Less => self.output.push_str("    lt\n"),
                    BinaryOp::Greater => self.output.push_str("    gt\n"),
                    BinaryOp::LessEqual => {
                        self.output.push_str("    gt\n");
                        self.output.push_str("    push 0\n");
                        self.output.push_str("    eq\n");
                    }
                    BinaryOp::GreaterEqual => {
                        self.output.push_str("    lt\n");
                        self.output.push_str("    push 0\n");
                        self.output.push_str("    eq\n");
                    }
                    _ => {
                        self.output.push_str("    ; unsupported binary op\n");
                    }
                }
            }

            Expression::Unary { op, operand } => {
                self.generate_expression(operand, program);
                
                match op {
                    UnaryOp::Neg => {
                        self.output.push_str("    push 0\n");
                        self.output.push_str("    swap\n");
                        self.output.push_str("    sub\n");
                    }
                    UnaryOp::Not => {
                        self.output.push_str("    push 0\n");
                        self.output.push_str("    eq\n");
                    }
                }
            }

            Expression::Call { function, args } => {
                self.output.push_str(&format!("    ; call {}\n", function));
                for arg in args.iter().rev() {
                    self.generate_expression(arg, program);
                }
                self.output.push_str(&format!("    call32 func_{}\n", function));
            }

            Expression::ModuleCall { module, function, args } => {
                if module == "stdio" && (function == "PrintStr" || function == "PrintlnStr") {
                    if !args.is_empty() {
                        if let Expression::String(s) = &args[0] {
                            self.emit_printstr(s, function == "PrintlnStr");
                            return;
                        }
                    }

                    // Fallback: generate a call to the stdio implementation
                    self.output.push_str(&format!("    ; call {}.{}\n", module, function));
                    for arg in args.iter().rev() {
                        self.generate_expression(arg, program);
                    }
                    self.output.push_str(&format!("    call32 func_{}_{}\n", module, function));
                    return;
                }

                self.output.push_str(&format!("    ; call {}.{}\n", module, function));
                for arg in args.iter().rev() {
                    self.generate_expression(arg, program);
                }
                self.output.push_str(&format!("    call32 func_{}_{}\n", module, function));
            }

            _ => {
                self.output.push_str("    ; unsupported expression\n");
                self.output.push_str("    push 0\n");
            }
        }
    }

    fn generate_label(&mut self, prefix: &str) -> String {
        self.label_counter += 1;
        format!("{}_{}_{}", prefix, self.current_function, self.label_counter)
    }

    fn emit_printstr(&mut self, s: &str, _newline: bool) {
        // Default to printing at last line start (as HelloWorld example)
        // Each VGA character cell is two bytes: (attr << 8) | char
        let base_addr = 0xB8F00u32;
        let attr = 0x07u32;

        for (i, ch) in s.as_bytes().iter().enumerate() {
            let addr = base_addr + (i as u32 * 2);
            let val = ((attr as u32) << 8) | (*ch as u32);
            self.output.push_str(&format!("    push 0x{:X}\n", addr));
            self.output.push_str(&format!("    push 0x{:X}\n", val));
            self.output.push_str("    store_abs\n");
        }
    }
}
